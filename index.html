<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Note Link v0.5.2 â€“ é–²è¦§/ç·¨é›†ï¼‹ç½«ç·šåŒæœŸï¼‹ä»˜ç®‹</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .chip { font-size: 12px; padding: 2px 8px; border-radius: 999px; border:1px solid #ddd; }
    .chip-view { background:#f1f5f9; }
    .chip-edit { background:#e6ffed; border-color:#b7f7c2; }
    .note { box-shadow: 0 2px 10px rgba(0,0,0,.06); resize: both; overflow:auto; }
    .note:focus-within { outline: 2px solid #60a5fa; }
    .note-header { cursor: move; user-select: none; background: rgba(0,0,0,.05); }
    .keso { font-variation-settings: 'opsz' 24; }
  </style>
</head>
<body class="bg-neutral-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;
    const PX_PER_MM = 3.78;
    const VERSION = "v0.5.2";
    const defaultStyle = { lineType: "ruled", ruledSpacingMm: 10, gridEnabled: false, gridSizeMm: 10 };
    const STORAGE_KEY = "notelink.v0.5.2";
    const MODE_KEY = "notelink.v0.5.2.mode";

    const loadState = () => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || ""); } catch { return null; } };
    const saveState = (s) => localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
    const loadMode = () => localStorage.getItem(MODE_KEY);
    const saveMode = (m) => localStorage.setItem(MODE_KEY, m);

    const uuid = () => Math.random().toString(36).slice(2, 10);

    function App() {
      const init = React.useMemo(() => {
        const s = loadState();
        if (s) return s;
        const first = { id: uuid(), title: "", content: "", style: { ...defaultStyle }, notes: [] };
        return { pages: [first], index: 0, pdfs: [] };
      }, []);

      const [pages, setPages] = useState(init.pages);
      const [index, setIndex] = useState(init.index);
      const [pdfs, setPdfs] = useState(init.pdfs);
      const current = pages[index];

      const [isMobile, setIsMobile] = useState(false);
      useEffect(() => {
        const onResize = () => setIsMobile(window.innerWidth < 640);
        onResize(); window.addEventListener('resize', onResize);
        return () => window.removeEventListener('resize', onResize);
      }, []);

      // é–²è¦§/ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚¹ãƒãƒ›ã¯æ—¢å®šã§é–²è¦§ï¼‰
      const [mode, setMode] = useState(() => {
        const stored = loadMode();
        if (stored === "view" || stored === "edit") return stored;
        return (window.innerWidth < 640) ? "view" : "edit";
      });
      const isView = mode === "view";
      const toggleMode = () => { const m = isView ? "edit" : "view"; setMode(m); saveMode(m); };

      useEffect(() => { saveState({ pages, index, pdfs }); }, [pages, index, pdfs]);

      // ç½«ç·šèƒŒæ™¯ã¨åŒæœŸï¼ˆè¡Œé–“ = ç½«ç·šãƒ”ãƒƒãƒï¼‰
      const paddingTopPx = 12;  // æœ€ä¸Šæ®µã®ä½™ç™½ï¼ˆèƒŒæ™¯é–‹å§‹ä½ç½®ã¨æƒãˆã‚‹ï¼‰
      const gapPx = current?.style?.ruledSpacingMm ? current.style.ruledSpacingMm * PX_PER_MM : 32;
      const ruledBg = useMemo(() => {
        if (!current) return undefined;
        if (current.style.lineType !== "ruled") return undefined;
        const size = `${gapPx}px`;
        return {
          backgroundImage: "linear-gradient(to bottom, rgba(0,0,0,0.08) 1px, transparent 1px)",
          backgroundSize: `100% ${size}`,
          backgroundPosition: `0px ${paddingTopPx}px`,
          lineHeight: `${gapPx}px`,
          paddingTop: `${paddingTopPx}px`,
        };
      }, [current, gapPx]);

      const gridOverlay = useMemo(() => {
        if (!current?.style.gridEnabled) return undefined;
        const sz = current.style.gridSizeMm * PX_PER_MM;
        const color = "rgba(0,0,0,0.08)";
        return { backgroundImage: `linear-gradient(${color} 1px, transparent 1px), linear-gradient(90deg, ${color} 1px, transparent 1px)`, backgroundSize: `${sz}px ${sz}px` };
      }, [current]);

      const addPage = () => {
        if (!current || isView) return;
        const newPage = { id: uuid(), title: current.title, content: "", style: { ...current.style }, notes: [] };
        const newPages = [...pages, newPage];
        setPages(newPages); setIndex(newPages.length - 1);
      };

      const prev = () => setIndex(i => Math.max(0, i - 1));
      const next = () => setIndex(i => Math.min(pages.length - 1, i + 1));

      const fileInputRef = useRef(null);
      const addPdf = (e) => {
        if (isView) return;
        const f = e.target.files?.[0]; if (!f) return;
        const item = { id: uuid(), name: f.name, addedAt: Date.now() };
        setPdfs(lst => [item, ...lst]); e.target.value = "";
      };
      const removePdf = (id) => { if (isView) return; setPdfs(lst => lst.filter(x => x.id !== id)); };

      const taRef = useRef(null);
      const updatePage = (patch) => {
        if (isView) return;
        setPages(prev => prev.map((p, i) => i === index ? { ...p, ...patch, style: { ...p.style, ...(patch.style || {}) } } : p));
      };
      const applyHighlight = () => {
        if (isView) return;
        const ta = taRef.current; if (!ta) return;
        const start = ta.selectionStart; const end = ta.selectionEnd; if (start === end) return;
        const before = current.content.slice(0, start);
        const sel = current.content.slice(start, end);
        const after = current.content.slice(end);
        updatePage({ content: `${before}[[HL]]${sel}[[/HL]]${after}` });
        setTimeout(() => { ta.focus(); ta.setSelectionRange(end + 10, end + 10); }, 0);
      };

      // ä»˜ç®‹ï¼šä½œæˆãƒ»ç§»å‹•ãƒ»ã‚µã‚¤ã‚ºå¤‰æ›´ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ï¼‰
      const [defaultSticky, setDefaultSticky] = useState("M"); // S/M/L
      const stickyPreset = (key) => {
        if (key === "S") return { w: 120, h: 90 };
        if (key === "L") return { w: 240, h: 180 };
        return { w: 160, h: 120 };
      };
      const addSticky = () => {
        if (isView) return;
        const { w, h } = stickyPreset(defaultSticky);
        const newNote = {
          id: uuid(),
          x: 24, y: 24,
          w, h,
          text: "ä»˜ç®‹",
        };
        const newNotes = [...(current.notes || []), newNote];
        updatePage({ notes: newNotes });
      };
      const updateNote = (id, patch) => {
        if (isView) return;
        const newNotes = (current.notes || []).map(n => n.id === id ? { ...n, ...patch } : n);
        updatePage({ notes: newNotes });
      };

      // ãƒ‰ãƒ©ãƒƒã‚°ç”¨
      const dragState = useRef({ id: null, offX: 0, offY: 0 });
      const onHeaderDown = (e, note) => {
        if (isView) return;
        const rect = e.currentTarget.parentElement.getBoundingClientRect();
        dragState.current = { id: note.id, offX: e.clientX - rect.left, offY: e.clientY - rect.top };
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
      };
      const onMove = (e) => {
        const { id, offX, offY } = dragState.current;
        if (!id) return;
        const container = document.getElementById("notesLayer").getBoundingClientRect();
        let x = e.clientX - container.left - offX;
        let y = e.clientY - container.top - offY;
        x = Math.max(0, Math.min(x, container.width - 40));
        y = Math.max(0, Math.min(y, container.height - 40));
        updateNote(id, { x, y });
      };
      const onUp = () => {
        dragState.current = { id: null, offX: 0, offY: 0 };
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };

      if (!current) return <div className="p-4">No pages</div>;

      const hasInput = (current.content ?? "").length > 0;
      const disableStyleSelect = hasInput || isView;

      return (
        <div className="w-full min-h-screen bg-neutral-50">
          {/* ä¸Šéƒ¨ãƒãƒ¼ */}
          <div className="sticky top-0 z-40 bg-white/80 backdrop-blur border-b">
            <div className="max-w-5xl mx-auto px-3 py-2 flex items-center gap-2">
              <div className="font-semibold text-neutral-700">Note Link <span className="text-xs text-neutral-500">{VERSION}</span></div>
              <div className="flex items-center gap-2 ml-2">
                <button className="px-2 py-1 rounded border" onClick={prev}>â—€</button>
                <div className="text-sm text-neutral-600">ãƒšãƒ¼ã‚¸ {index + 1} / {pages.length}</div>
                <button className="px-2 py-1 rounded border" onClick={next}>â–¶</button>
              </div>
              <div className="flex-1" />
              <span className={"chip " + (isView ? "chip-view" : "chip-edit")}>{isView ? "é–²è¦§ãƒ¢ãƒ¼ãƒ‰" : "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰"}</span>
              <button className="ml-2 px-2 py-1 rounded border" onClick={toggleMode}>
                {isView ? "ç·¨é›†ã¸åˆ‡æ›¿" : "é–²è¦§ã¸åˆ‡æ›¿"}
              </button>

              <div className="flex items-center gap-2 ml-2">
                <input type="file" accept="application/pdf" className="hidden" ref={fileInputRef} onChange={addPdf} />
                <button className="px-2 py-1 rounded border btn" onClick={() => !isView && fileInputRef.current?.click()} disabled={isView}>PDFè¿½åŠ </button>
                <button className="px-2 py-1 rounded border btn" onClick={() => isView ? null : alert('ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼ˆãƒ‡ãƒ¢ï¼‰å®Œäº†')} disabled={isView}>ä¿å­˜</button>
                <button className="px-2 py-1 rounded bg-black text-white">å…±æœ‰</button>
              </div>
            </div>
          </div>

          {/* æœ¬ä½“ */}
          <div className="max-w-5xl mx-auto p-3 grid grid-cols-1 lg:grid-cols-[1fr_320px] gap-3">
            {/* ãƒãƒ¼ãƒˆé ˜åŸŸ */}
            <div className="bg-white border rounded-xl shadow-sm">
              <div className="p-3 sm:p-4">
                {/* ã‚¿ã‚¤ãƒˆãƒ«è¡Œ */}
                <div className="flex flex-col sm:flex-row gap-2 mb-3">
                  <input
                    value={current.title}
                    onChange={(e) => !isView && setPages(prev => prev.map((p,i)=> i===index? {...p, title: e.target.value}:p))}
                    placeholder="ã‚¿ã‚¤ãƒˆãƒ«"
                    className="px-3 py-2 border rounded w-full text-base sm:text-lg"
                    readOnly={isView}
                  />
                  <div className="flex gap-2 items-center">
                    <button className="px-3 py-2 rounded border btn" onClick={addPage} disabled={isView}>ï¼‹ ãƒšãƒ¼ã‚¸è¿½åŠ </button>
                    <div className="flex items-center gap-1">
                      <label className="text-sm text-neutral-600">ä»˜ç®‹ã‚µã‚¤ã‚º</label>
                      <select className="px-2 py-1 border rounded" value={defaultSticky} onChange={(e)=>setDefaultSticky(e.target.value)} disabled={isView}>
                        <option value="S">S</option>
                        <option value="M">M</option>
                        <option value="L">L</option>
                      </select>
                    </div>
                    <button className="px-3 py-2 rounded border btn" onClick={addSticky} disabled={isView}>ä»˜ç®‹</button>
                    <button className="px-3 py-2 rounded border btn" onClick={applyHighlight} disabled={isView}>ãƒã‚¤ãƒ©ã‚¤ãƒˆ</button>
                  </div>
                </div>

                {/* ãƒ„ãƒ¼ãƒ«ï¼ˆè¦‹ãŸç›®ã®ã¿ï¼‰ */}
                <div className="flex flex-wrap items-center gap-2 mb-1 text-sm">
                  <span className="text-neutral-600">ãƒ„ãƒ¼ãƒ«:</span>
                  <button className="px-2 py-1 rounded border btn" disabled={isView}>âœ’ ãƒšãƒ³</button>
                  <button className="px-2 py-1 rounded border btn" disabled={isView}>ğŸ§½ æ¶ˆã—ã‚´ãƒ </button>
                  <button className="px-2 py-1 rounded border btn" disabled={isView}>ğŸ– ãƒãƒ¼ã‚«ãƒ¼</button>
                  <select className="px-2 py-1 border rounded" disabled={isView}>
                    <option>ç´°</option><option>ä¸­</option><option>å¤ª</option>
                  </select>
                </div>

                {/* ç½«ç·š/æ–¹çœ¼ */}
                <div className="flex flex-wrap gap-2 items-center mb-3">
                  <label className="text-sm text-neutral-600">ç½«ç·šå¹…</label>
                  <select
                    className="px-2 py-1 border rounded"
                    value={String(current.style.ruledSpacingMm)}
                    onChange={(e) => {
                      if (isView) return;
                      if ((current.content ?? '').length > 0) return;
                      setPages(prev => prev.map((p,i)=> i===index? {...p, style:{...p.style, ruledSpacingMm:Number(e.target.value)}}:p));
                    }}
                    disabled={isView || (current.content ?? '').length > 0}
                  >
                    <option value="10">10 mm</option>
                    <option value="8">8 mm</option>
                    <option value="6">6 mm</option>
                  </select>
                  {(current.content ?? '').length > 0 && <span className="text-xs text-neutral-500">ï¼ˆå…¥åŠ›é–‹å§‹å¾Œã¯ç½«ç·šå¹…ã‚’å›ºå®šï¼‰</span>}

                  <div className="w-px h-6 bg-neutral-200 mx-1"></div>

                  <button
                    className={"px-3 py-1 rounded border btn " + (current.style.gridEnabled ? "bg-black text-white" : "")}
                    onClick={() => !isView && setPages(prev => prev.map((p,i)=> i===index? {...p, style:{...p.style, gridEnabled: !p.style.gridEnabled}}:p))}
                    disabled={isView}
                  >ã‚°ãƒ©ãƒ•å‡ç›® {current.style.gridEnabled ? "ON" : "OFF"}</button>

                  <select
                    className="px-2 py-1 border rounded"
                    value={String(current.style.gridSizeMm)}
                    onChange={(e) => !isView && setPages(prev => prev.map((p,i)=> i===index? {...p, style:{...p.style, gridSizeMm:Number(e.target.value)}}:p))}
                    disabled={isView}
                  >
                    <option value="10">10 mm</option>
                    <option value="8">8 mm</option>
                    <option value="5">5 mm</option>
                  </select>
                </div>

                {/* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ï¼‹ä»˜ç®‹ãƒ¬ã‚¤ãƒ¤ */}
                <div className="relative border rounded-xl overflow-hidden min-h-[60vh]">
                  <div className="absolute inset-0 pointer-events-none" style={gridOverlay}></div>

                  {/* ä»˜ç®‹ãƒ¬ã‚¤ãƒ¤ */}
                  <div id="notesLayer" className="absolute inset-0" style={{ pointerEvents: isView ? "none" : "auto" }}>
                    {(current.notes || []).map(note => (
                      <div
                        key={note.id}
                        className="note absolute bg-yellow-200 rounded"
                        style={{ left: note.x, top: note.y, width: note.w, height: note.h }}
                      >
                        <div className="note-header text-xs px-2 py-1 rounded-t flex items-center justify-between" onMouseDown={(e)=>onHeaderDown(e, note)}>
                          <span>ä»˜ç®‹</span>
                          <button className="text-xs px-1 border rounded btn" onClick={()=>updateNote(note.id, { })} disabled>â˜°</button>
                        </div>
                        <div
                          contentEditable={!isView}
                          suppressContentEditableWarning
                          className="p-2 text-sm"
                          onInput={(e)=>updateNote(note.id, { text: e.currentTarget.textContent })}
                        >{note.text}</div>
                      </div>
                    ))}
                  </div>

                  {/* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ */}
                  <textarea
                    ref={taRef}
                    value={current.content}
                    onChange={(e) => !isView && setPages(prev => prev.map((p,i)=> i===index? {...p, content: e.target.value}:p))}
                    placeholder="ã“ã“ã«ãƒãƒ¼ãƒˆã‚’æ›¸ãå§‹ã‚ã‚‹â€¦ï¼ˆé–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§ã¯ç·¨é›†ã§ãã¾ã›ã‚“ï¼‰"
                    className="w-full h-[60vh] p-3 text-base bg-white"
                    style={ruledBg}
                    readOnly={isView}
                  ></textarea>
                </div>
              </div>
            </div>

            {/* ã‚µã‚¤ãƒ‰ãƒãƒ¼ */}
            <div className="space-y-3">
              <div className="bg-white border rounded-xl shadow-sm p-3">
                <div className="font-medium mb-2">PDFãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆä¿ç®¡ãƒ»ç®¡ç† å©ãå°ï¼‰</div>
                <ul className="space-y-2 max-h-[40vh] overflow-auto">
                  {pdfs.length === 0 && (<li className="text-sm text-neutral-500">ã¾ã PDFãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€ŒPDFè¿½åŠ ã€ã‹ã‚‰ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚</li>)}
                  {pdfs.map(p => (
                    <li key={p.id} className="flex items-center justify-between text-sm border rounded px-2 py-1">
                      <span className="truncate" title={p.name}>{p.name}</span>
                      <button className="px-2 py-1 rounded border btn" onClick={() => removePdf(p.id)} disabled={isView}>å‰Šé™¤</button>
                    </li>
                  ))}
                </ul>
              </div>

              <div className="bg-white border rounded-xl shadow-sm p-3">
                <div className="font-medium mb-1">ãƒ¢ãƒ¼ãƒ‰ã®ä½¿ã„åˆ†ã‘</div>
                <ul className="text-sm text-neutral-700 list-disc list-inside space-y-1">
                  <li>ã‚¹ãƒãƒ›ã¯æ—¢å®šã§ <b>é–²è¦§</b>ã€‚å¿…è¦ãªã¨ãã ã‘ã€Œç·¨é›†ã¸åˆ‡æ›¿ã€ã€‚</li>
                  <li>é–²è¦§æ™‚ã¯ã€å…¥åŠ›ã‚„ãƒšãƒ¼ã‚¸è¿½åŠ ãªã©ã®ç·¨é›†ãƒœã‚¿ãƒ³ãŒç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™ã€‚</li>
                  <li>ç·¨é›†/é–²è¦§ã®çŠ¶æ…‹ã¯ç«¯æœ«ã«ä¿å­˜ã•ã‚Œã€æ¬¡å›ã‚‚å¼•ãç¶™ãŒã‚Œã¾ã™ã€‚</li>
                  <li>ç½«ç·šãƒ”ãƒƒãƒã¨è¡Œé–“ã‚’**åŒæœŸ**ã—ã¦ã€æ”¹è¡Œã§ç½«ç·šã¨ãšã‚Œã«ããã—ã¦ã„ã¾ã™ã€‚</li>
                  <li>ä»˜ç®‹ã¯ãƒœã‚¿ãƒ³ã§è¿½åŠ ã€‚S/M/L ã®åˆæœŸã‚µã‚¤ã‚ºã‚’é¸ã¹ã€ã‚ã¨ã‹ã‚‰è‡ªç”±ã«ãƒªã‚µã‚¤ã‚ºã§ãã¾ã™ã€‚</li>
                </ul>
              </div>
            </div>
          </div>

          {/* ä¸‹éƒ¨ãƒšãƒ¼ã‚¸ãƒ£ï¼ˆãƒ¢ãƒã‚¤ãƒ«ï¼‰ */}
          <div className="sm:hidden sticky bottom-0 z-40 bg-white/90 backdrop-blur border-t">
            <div className="max-w-5xl mx-auto px-3 py-2 flex items-center gap-2">
              <button className="px-2 py-1 rounded border" onClick={prev}>â—€</button>
              <div className="text-sm text-neutral-600">ãƒšãƒ¼ã‚¸ {index + 1} / {pages.length}</div>
              <button className="px-2 py-1 rounded border" onClick={next}>â–¶</button>
              <div className="flex-1"></div>
              <button className="px-3 py-1 rounded bg-black text-white">å…±æœ‰</button>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
