<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Note Link v0.9（縦折りたたみ・ページ移動分離・指示外変更なし）</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --accent:#50C878; --muted:#374151; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      overflow: hidden; }

    /* ヘッダー */
    header { height: 48px; display:flex; align-items:center; justify-content:space-between; padding: 0 12px; background: var(--panel); border-bottom:1px solid var(--muted); user-select:none; gap:8px; }
    header .brand { display:flex; gap:8px; align-items:center; font-weight:700; }
    header .brand .dot { width:10px; height:10px; border-radius:50%; background:var(--accent); box-shadow:0 0 12px var(--accent); }
    header .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pager { display:flex; gap:6px; align-items:center; background:#0b1220; border:1px solid var(--muted); border-radius:12px; padding:4px 8px; }
    .pager .count { min-width:64px; text-align:center; font-variant-numeric: tabular-nums; }

    button, input[type='color'], select, details { background:#0b1220; color:var(--ink); border:1px solid var(--muted); border-radius:10px; padding:8px 10px; font-size:14px; height:34px; }
    button{ cursor:pointer; }
    details{ padding:6px 10px; height:auto; }
    summary{ cursor:pointer; }
    button:hover, details:hover { border-color:var(--accent); }
    button.active { outline:2px solid var(--accent); }

    /* レイアウト */
    .wrap { display:grid; grid-template-columns: 56px 1fr; grid-template-rows: 1fr; height: calc(100% - 48px); transition: grid-template-columns .2s ease; }
    /* 折りたたみ時でも 44px を残して見失わないようにする */
    .wrap.collapsedX { grid-template-columns: 44px 1fr; }

    .sidebar { position:relative; background:var(--panel); border-right:1px solid var(--muted); padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto; }
    /* 垂直方向の折りたたみ（高さを抑える）*/
    .sidebar.collapsedY { max-height: 44px; overflow:hidden; }

    .sidebar .toggleBar { position:absolute; top:8px; right:-10px; width:22px; height:22px; border-radius:50%; background:#0b1220; border:1px solid var(--muted); display:grid; place-items:center; font-size:12px; cursor:pointer; }
    .toolGroup { display:flex; flex-direction:column; align-items:center; gap:4px; }
    .tool { width:40px; height:40px; border-radius:12px; display:grid; place-items:center; border:1px solid var(--muted); background:#0b1220; }
    .tool.active { border-color:var(--accent); }
    .gear { width:26px; height:26px; border-radius:8px; display:none; place-items:center; border:1px solid var(--muted); font-size:12px; opacity:.85; }
    .toolGroup.active .gear{ display:grid; }
    .tool-label { font-size:10px; text-align:center; opacity:.8; }

    .stage { position:relative; background: #0b1220; }
    canvas { display:block; background: transparent; width:100%; height:100%; }
    /* キャンバス右上の旧インジケータは非表示（ヘッダーへ移動）*/
    .pageIndicator { display:none; }

    .flyout { position:absolute; top:72px; left:72px; width:360px; max-width:90vw; max-height:70vh; overflow:auto; background:rgba(17,24,39,.98); border:1px solid var(--muted); border-radius:14px; box-shadow:0 10px 32px rgba(0,0,0,.45); padding:10px; backdrop-filter: blur(6px); }
    .flyout.hidden { display:none; }
    .flyoutHeader { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
    .flyoutHeader .title { font-weight:700; }
    .dragHandle { cursor:move; opacity:.8; }
    .closeX { width:28px; height:28px; border-radius:8px; display:grid; place-items:center; }

    .panel h3 { margin:6px 0 8px; font-size:14px; opacity:.9; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    .row input[type='range']{ width: 160px; }
    .hint { font-size:12px; opacity:.75; line-height:1.4; }

    .tabbar { display:flex; gap:6px; margin-bottom:6px; flex-wrap:wrap; }
    .tabbar button { height:30px; padding:4px 8px; border-radius:8px; }
    .tabbar button.active { background: #10212f; border-color: var(--accent); }

    .swatch { width:22px; height:22px; border-radius:6px; border:1px solid #64748b; cursor:pointer; }
    .swatchRow { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .textInput { position:absolute; background:#ffffff; color:#111827; border:1px solid #94a3b8; border-radius:6px; padding:4px 6px; min-width:120px; outline:none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
  <header>
    <div class="brand"><span class="dot"></span> Note Link v0.9</div>
    <div class="actions">
      <button id="btnUndo" title="元に戻す (Ctrl+Z)">↶</button>
      <button id="btnRedo" title="やり直す (Ctrl+Y)">↷</button>

      <!-- ページ移動＆増減：ここに集約 -->
      <div class="pager">
        <button id="btnPrevPage" title="前のページへ">◀</button>
        <span id="pageCount" class="count">1 / 1</span>
        <button id="btnNextPage" title="次のページへ">▶</button>
        <button id="btnAddPage"  title="ページ追加">＋</button>
        <button id="btnDelPage"  title="このページを削除">－</button>
      </div>

      <button id="btnExportPng" title="PNG書き出し">PNG出力</button>
      <button id="btnSaveDoc" title="ノート保存（JSON）">保存</button>
      <button id="btnLoadDoc" title="ノート読込（JSON）">読込</button>
      <input type="file" id="fileLoad" accept="application/json" style="display:none" />
      <input type="file" id="fileBg" accept="image/*" style="display:none" />
      <button id="btnSetBg" title="背景画像（PNG/JPG）を読み込み">背景</button>
      <input type="file" id="filePdf" accept="application/pdf" style="display:none" />
      <button id="btnSetPdf" title="PDFを背景として読み込み（各ページへ分割）">PDF</button>
    </div>
  </header>

  <div class="wrap" id="wrap">
    <aside class="sidebar" id="sidebar">
      <!-- 垂直折りたたみ：△=展開／▽=折りたたみ -->
      <div class="toggleBar" id="toggleBar" title="ツールバーを縦に折りたたむ/戻す">△</div>
      <div class="toolGroup" id="groupPen">
        <button class="tool active" id="toolPen" title="ペン">✎</button>
        <button class="gear" id="gearPen" title="ペン設定">⚙</button>
        <div class="tool-label">ペン</div>
      </div>
      <div class="toolGroup" id="groupHL">
        <button class="tool" id="toolHighlighter" title="蛍光ペン">🖍</button>
        <button class="gear" id="gearHL" title="蛍光ペン設定">⚙</button>
        <div class="tool-label">蛍光</div>
      </div>
      <div class="toolGroup" id="groupEraser">
        <button class="tool" id="toolEraser" title="消しゴム（ストローク消去）">⌫</button>
        <button class="gear" id="gearEraser" title="消しゴム設定">⚙</button>
        <div class="tool-label">消</div>
      </div>
      <div class="toolGroup" id="groupPan">
        <button class="tool" id="toolPan" title="移動/ズーム（2本指・ホイール）">🖐</button>
        <button class="gear" id="gearPan" title="移動設定">⚙</button>
        <div class="tool-label">移動</div>
      </div>
      <div class="toolGroup" id="groupGuide">
        <button class="tool" id="toolGuide" title="罫線・ガイド">📏</button>
        <button class="gear" id="gearGuide" title="罫線・ガイド設定">⚙</button>
        <div class="tool-label">ガイド</div>
      </div>
      <div class="toolGroup" id="groupText">
        <button class="tool" id="toolText" title="キーボード（テキスト）">⌨</button>
        <button class="gear" id="gearText" title="テキスト設定">⚙</button>
        <div class="tool-label">テキスト</div>
      </div>
      <div class="toolGroup" id="groupBg">
        <button class="tool" id="toolBg" title="背景色">🎨</button>
        <button class="gear" id="gearBg" title="背景色設定">⚙</button>
        <div class="tool-label">背景</div>
      </div>
    </aside>

    <main class="stage" id="stage">
      <canvas id="canvas"></canvas>
      <div class="pageIndicator" id="pageIndicator">1 / 1</div>

      <div class="flyout hidden" id="flyout">
        <div class="flyoutHeader">
          <div class="title" id="flyoutTitle">設定</div>
          <div style="display:flex; gap:6px; align-items:center;">
            <span class="dragHandle">⠿</span>
            <button class="closeX" id="flyoutClose">✕</button>
          </div>
        </div>
        <div class="tabbar" id="tabbar"></div>
        <div id="flyoutBody"></div>
      </div>

      <input class="textInput" id="textInput" style="display:none" />
    </main>
  </div>

  <!-- Templates（前バージョンと同じ。省略せず全部維持） -->
  <template id="tmpl-pen"><div class="panel"><h3>ペン設定</h3>
    <div class="row"><label>色</label><input type="color" id="color" value="#fffae6" /></div>
    <div class="row"><label>基準太さ</label><input type="range" id="size" min="1" max="30" value="3" /><span id="sizeVal">3</span></div>
    <div class="row"><label>不透明度</label><input type="range" id="alpha" min="0.05" max="1" step="0.05" value="1" /><span id="alphaVal">1</span></div>
    <details><summary>筆圧/傾き/パーム（詳細）</summary>
      <div class="row"><label><input type="checkbox" id="pressureEnable" checked /> 筆圧を反映</label><span class="hint">（4096段階相当→0–1に正規化）</span></div>
      <div class="row"><label>筆圧感度</label><input type="range" id="pressureGain" min="0" max="3" step="0.1" value="1.2" /><span id="pressureGainVal">1.2</span></div>
      <div class="row"><label><input type="checkbox" id="tiltEnable" /> 傾きで太さ補正</label></div>
      <div class="row"><label>傾き感度</label><input type="range" id="tiltGain" min="0" max="2" step="0.1" value="0.6" /><span id="tiltGainVal">0.6</span></div>
      <div class="row"><label><input type="checkbox" id="palmReject" checked /> パームリジェクション（タッチ無効）</label></div>
      <div class="row"><label><input type="checkbox" id="penOnly" /> ペン専用モード（pen/mouseのみ）</label></div>
    </details></div></template>

  <template id="tmpl-hl"><div class="panel"><h3>蛍光ペン設定</h3>
    <div class="row"><label>色</label><input type="color" id="hlColor" value="#ffff66" /></div>
    <div class="row"><label>太さ</label><input type="range" id="hlSize" min="4" max="60" value="16" /><span id="hlSizeVal">16</span></div>
    <div class="row hint">※ 不透明度は最大0.4に自動制限</div></div></template>

  <template id="tmpl-eraser"><div class="panel"><h3>消しゴム設定</h3>
    <div class="row"><label>消去範囲</label><input type="range" id="eraserRadius" min="8" max="48" value="16" /><span id="eraserRadiusVal">16</span></div>
    <div class="row hint">※ いまはストローク単位。将来「ラバーバー型」も追加可。</div></div></template>

  <template id="tmpl-pan"><div class="panel"><h3>移動/ズーム</h3>
    <div class="row"><label>最小/最大ズーム</label><input type="range" id="zoomMin" min="0.2" max="1" step="0.05" value="0.2" /><span>0.2x〜</span>
      <input type="range" id="zoomMax" min="2" max="8" step="0.5" value="6" /><span>〜6x</span></div>
    <div class="row"><label><input type="checkbox" id="smoothPan" checked/> 慣性スクロール</label></div></div></template>

  <template id="tmpl-guide"><div class="panel"><h3>罫線・ガイド</h3>
    <div class="row"><label for="guidePreset">プリセット</label>
      <select id="guidePreset">
        <option value="none">— 選択 —</option>
        <option value="A7">横罫 A罫（7mm）</option>
        <option value="B6">横罫 B罫（6mm）</option>
        <option value="C5">横罫 C罫（5mm）</option>
        <option value="U8">横罫 U罫（8mm）</option>
        <option value="UL10">横罫 UL罫（10mm）</option>
        <option value="ENG7">英習罫（7mm・中間線）</option>
        <option value="DOT6">ドット入り横罫（6mm）</option>
        <option value="GRID5">方眼 5mm</option>
        <option value="GRID10">方眼 10mm</option>
        <option value="ELM10">小学生マス 10mm（5マス毎太線）</option>
        <option value="ELM12">小学生マス 12mm（4マス毎太線）</option>
        <option value="ELM15">小学生マス 15mm（3マス毎太線）</option>
      </select></div>
    <div class="row">
      <label for="guideType">種類</label>
      <select id="guideType">
        <option value="none">なし</option>
        <option value="ruled">横罫（大学ノート）</option>
        <option value="grid">方眼</option>
        <option value="dot">ドット方眼</option>
        <option value="eng">英習罫</option>
      </select></div>
    <div class="row"><label>間隔(px)</label><input type="range" id="guideSpacing" min="8" max="100" value="28" /><span id="guideSpacingVal">28</span></div>
    <div class="row"><label>左マージン(px)</label><input type="range" id="guideMargin" min="0" max="240" value="40" /><span id="guideMarginVal">40</span></div>
    <div class="row"><label>不透明度</label><input type="range" id="guideOpacity" min="0.05" max="1" step="0.05" value="0.25" /><span id="guideOpacityVal">0.25</span></div>
    <div class="row"><label><input type="checkbox" id="guideExport" checked /> 出力(PNG)に含める</label></div>
    <div class="hint">※ 英習罫は各行の中間にガイド線（薄色）を引きます。</div></div></template>

  <template id="tmpl-text"><div class="panel"><h3>テキスト（キーボード）</h3>
    <div class="row"><label>色</label><input type="color" id="textColor" value="#ffffff" /></div>
    <div class="row"><label>文字サイズ</label><input type="range" id="textSize" min="10" max="72" value="18" /><span id="textSizeVal">18</span></div>
    <div class="row"><label>フォント</label>
      <select id="textFont">
        <option value="'Noto Sans JP',sans-serif">ゴシック</option>
        <option value="'Hiragino Mincho ProN','Yu Mincho',serif">明朝</option>
        <option value="'Courier New',monospace">等幅</option>
      </select></div>
    <div class="hint">キャンバスをクリック→入力→Enterで確定、Escで取消。確定後は移動不可（今後対応可）。</div></div></template>

  <template id="tmpl-bg"><div class="panel"><h3>背景色</h3>
    <div class="row">決め打ち6色：</div>
    <div class="row swatchRow">
      <div class="swatch" data-c="#0b1220" style="background:#0b1220" title="黒"></div>
      <div class="swatch" data-c="#ffffff" style="background:#ffffff" title="白"></div>
      <div class="swatch" data-c="#e0f7ff" style="background:#e0f7ff" title="淡青"></div>
      <div class="swatch" data-c="#e0ffe7" style="background:#e0ffe7" title="淡緑"></div>
      <div class="swatch" data-c="#fffce0" style="background:#fffce0" title="淡黄"></div>
      <div class="swatch" data-c="#ffe0ef" style="background:#ffe0ef" title="淡ピンク"></div>
    </div>
    <div class="row"><label>カスタム</label><input type="color" id="bgPicker" value="#0b1220" /></div>
    <div class="hint">※ 背景色は各ページ共通。PDFや画像背景がある場合はそちらが優先表示されます。</div>
  </div></template>

  <script>
    // ====== 状態 ======
    const state = {
      pages: [], pageIndex: 0, currentTool: 'pen',
      view: { scale: 1, x: 0, y: 0, min: 0.2, max: 6 }, drawing: false, pointerId: null, stroke: null,
      undoStack: [], redoStack: [],
      guide: { type: 'none', spacing: 28, opacity: 0.25, marginLeft: 40, includeExport: true, thickEvery: 0, engMid: 0.5 },
      pen: { pressureEnable: true, pressureGain: 1.2, tiltEnable: false, tiltGain: 0.6, palmReject: true, penOnly: false },
      hl: { color: '#ffff66', size: 16 },
      eraser: { radius: 16 },
      text: { color: '#ffffff', size: 18, font: "'Noto Sans JP',sans-serif" },
      ui: { flyoutOpen: false, flyoutTab: '' },
      bgColor: '#0b1220'
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stage = document.getElementById('stage');
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    function resizeCanvas(){ const r = stage.getBoundingClientRect(); canvas.width = Math.floor(r.width * dpr); canvas.height = Math.floor(r.height * dpr); ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr, dpr); render(); }
    window.addEventListener('resize', resizeCanvas);

    function newPage(){ return { strokes: [], texts: [], bg: null, bgSize: {w:0,h:0}, bgBitmap: null }; }
    state.pages.push(newPage());

    // ====== サイドバー折りたたみ（垂直）＆横幅最小化 ======
    const wrap = document.getElementById('wrap');
    const sidebar = document.getElementById('sidebar');
    const toggleBar = document.getElementById('toggleBar');
    toggleBar.addEventListener('click', ()=>{
      // 垂直方向（高さ）の折りたたみ
      sidebar.classList.toggle('collapsedY');
      // 横方向は最小幅を残す（見失わない）
      wrap.classList.toggle('collapsedX');
      toggleBar.textContent = sidebar.classList.contains('collapsedY') ? '▽' : '△';
      resizeCanvas();
    });

    // ====== サイドバー・ツール ======
    const groupPen = document.getElementById('groupPen');
    const groupHL = document.getElementById('groupHL');
    const groupEraser = document.getElementById('groupEraser');
    const groupPan = document.getElementById('groupPan');
    const groupGuide = document.getElementById('groupGuide');
    const groupText = document.getElementById('groupText');
    const groupBg = document.getElementById('groupBg');

    const toolPen = document.getElementById('toolPen');
    const toolHighlighter = document.getElementById('toolHighlighter');
    const toolEraser = document.getElementById('toolEraser');
    const toolPan = document.getElementById('toolPan');
    const toolGuide = document.getElementById('toolGuide');
    const toolText = document.getElementById('toolText');
    const toolBg = document.getElementById('toolBg');

    function setTool(t){
      state.currentTool = t;
      [toolPen, toolHighlighter, toolEraser, toolPan, toolGuide, toolText, toolBg].forEach(el=>el.classList.remove('active'));
      ({pen:toolPen, hl:toolHighlighter, eraser:toolEraser, pan:toolPan, guide:toolGuide, text:toolText, bg:toolBg}[t]).classList.add('active');
      [groupPen, groupHL, groupEraser, groupPan, groupGuide, groupText, groupBg].forEach(g=>g.classList.remove('active'));
      ({pen:groupPen, hl:groupHL, eraser:groupEraser, pan:groupPan, guide:groupGuide, text:groupText, bg:groupBg}[t]).classList.add('active');
      if(state.ui.flyoutOpen){ openFlyout(t); }
    }
    toolPen.onclick = ()=> setTool('pen');
    toolHighlighter.onclick = ()=> setTool('hl');
    toolEraser.onclick = ()=> setTool('eraser');
    toolPan.onclick = ()=> setTool('pan');
    toolGuide.onclick = ()=> { setTool('guide'); openFlyout('guide'); };
    toolText.onclick = ()=> setTool('text');
    toolBg.onclick = ()=> setTool('bg');

    // ====== フライアウト（ギア） ======
    const flyout = document.getElementById('flyout');
    const flyoutTitle = document.getElementById('flyoutTitle');
    const flyoutBody = document.getElementById('flyoutBody');
    const flyoutClose = document.getElementById('flyoutClose');
    const tabbar = document.getElementById('tabbar');

    const gearPen = document.getElementById('gearPen');
    const gearHL = document.getElementById('gearHL');
    const gearEraser = document.getElementById('gearEraser');
    const gearPan = document.getElementById('gearPan');
    const gearGuide = document.getElementById('gearGuide');
    const gearText = document.getElementById('gearText');
    const gearBg = document.getElementById('gearBg');

    gearPen.onclick = ()=> openFlyout('pen');
    gearHL.onclick = ()=> openFlyout('hl');
    gearEraser.onclick = ()=> openFlyout('eraser');
    gearPan.onclick = ()=> openFlyout('pan');
    gearGuide.onclick = ()=> openFlyout('guide');
    gearText.onclick = ()=> openFlyout('text');
    gearBg.onclick = ()=> openFlyout('bg');

    flyoutClose.onclick = ()=> { flyout.classList.add('hidden'); state.ui.flyoutOpen=false; };

    function openFlyout(tab){
      state.ui.flyoutOpen = true; state.ui.flyoutTab = tab;
      flyout.classList.remove('hidden');
      const titles = { pen:'ペン設定', hl:'蛍光ペン設定', eraser:'消しゴム設定', pan:'移動/ズーム', guide:'罫線・ガイド', text:'テキスト設定', bg:'背景色' };
      flyoutTitle.textContent = titles[tab] || '設定';
      tabbar.innerHTML='';
      const tabs = ['pen','hl','eraser','pan','guide','text','bg'];
      tabs.forEach(t=>{ const b=document.createElement('button'); b.textContent=titles[t]; if(t===tab) b.classList.add('active'); b.onclick=()=> openFlyout(t); tabbar.appendChild(b); });
      const tmpl = document.getElementById(`tmpl-${tab}`);
      flyoutBody.innerHTML='';
      flyoutBody.appendChild(tmpl.content.cloneNode(true));
      bindControls(tab);
    }

    // ドラッグでパネル移動
    (function(){
      const handle = document.querySelector('.dragHandle');
      let dragging=false, sx=0, sy=0, ox=0, oy=0;
      handle?.addEventListener('pointerdown', (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; const r=flyout.getBoundingClientRect(); ox=r.left; oy=r.top; handle.setPointerCapture(e.pointerId); });
      handle?.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; flyout.style.left=(ox+dx)+'px'; flyout.style.top=(oy+dy)+'px'; });
      handle?.addEventListener('pointerup', ()=> dragging=false);
      handle?.addEventListener('pointercancel', ()=> dragging=false);
    })();

    // ====== コントロールのバインド ======
    function bindControls(tab){
      if(tab==='pen'){
        const color = document.getElementById('color');
        const size = document.getElementById('size'); const sizeVal = document.getElementById('sizeVal');
        const alpha = document.getElementById('alpha'); const alphaVal = document.getElementById('alphaVal');
        const pressureEnable = document.getElementById('pressureEnable');
        const pressureGain = document.getElementById('pressureGain'); const pressureGainVal = document.getElementById('pressureGainVal');
        const tiltEnable = document.getElementById('tiltEnable');
        const tiltGain = document.getElementById('tiltGain'); const tiltGainVal = document.getElementById('tiltGainVal');
        const palmReject = document.getElementById('palmReject');
        const penOnly = document.getElementById('penOnly');
        color.value = state.penColor || '#fffae6';
        size.value = state.baseSize || 3; sizeVal.textContent = size.value;
        alpha.value = state.baseAlpha || 1; alphaVal.textContent = alpha.value;
        pressureEnable.checked = state.pen.pressureEnable; pressureGain.value = state.pen.pressureGain; pressureGainVal.textContent = pressureGain.value;
        tiltEnable.checked = state.pen.tiltEnable; tiltGain.value = state.pen.tiltGain; tiltGainVal.textContent = tiltGain.value;
        palmReject.checked = state.pen.palmReject; penOnly.checked = state.pen.penOnly;
        color.oninput = ()=> state.penColor = color.value;
        size.oninput = ()=>{ state.baseSize = parseFloat(size.value); sizeVal.textContent=size.value; };
        alpha.oninput = ()=>{ state.baseAlpha = parseFloat(alpha.value); alphaVal.textContent=alpha.value; };
        pressureEnable.onchange = ()=> state.pen.pressureEnable = pressureEnable.checked;
        pressureGain.oninput = ()=>{ state.pen.pressureGain = parseFloat(pressureGain.value); pressureGainVal.textContent=pressureGain.value; };
        tiltEnable.onchange = ()=> state.pen.tiltEnable = tiltEnable.checked;
        tiltGain.oninput = ()=>{ state.pen.tiltGain = parseFloat(tiltGain.value); tiltGainVal.textContent=tiltGain.value; };
        palmReject.onchange = ()=> state.pen.palmReject = palmReject.checked;
        penOnly.onchange = ()=> state.pen.penOnly = penOnly.checked;
      }
      if(tab==='hl'){
        const c = document.getElementById('hlColor'); const s = document.getElementById('hlSize'); const sv = document.getElementById('hlSizeVal');
        c.value = state.hl.color; s.value = state.hl.size; sv.textContent = s.value;
        c.oninput = ()=> state.hl.color = c.value;
        s.oninput = ()=>{ state.hl.size = parseFloat(s.value); sv.textContent=s.value; };
      }
      if(tab==='eraser'){
        const r = document.getElementById('eraserRadius'); const rv = document.getElementById('eraserRadiusVal'); r.value = state.eraser.radius; rv.textContent=r.value; r.oninput = ()=>{ state.eraser.radius = parseFloat(r.value); rv.textContent=r.value; };
      }
      if(tab==='pan'){
        const zmin = document.getElementById('zoomMin'); const zmax = document.getElementById('zoomMax'); const smooth = document.getElementById('smoothPan');
        zmin.value = state.view.min; zmax.value = state.view.max; smooth.checked = true;
        zmin.oninput = ()=> state.view.min = parseFloat(zmin.value);
        zmax.oninput = ()=> state.view.max = parseFloat(zmax.value);
      }
      if(tab==='guide'){
        const guidePreset = document.getElementById('guidePreset');
        const guideType = document.getElementById('guideType');
        const guideSpacing = document.getElementById('guideSpacing');
        const guideSpacingVal = document.getElementById('guideSpacingVal');
        const guideMargin = document.getElementById('guideMargin');
        const guideMarginVal = document.getElementById('guideMarginVal');
        const guideOpacity = document.getElementById('guideOpacity');
        const guideOpacityVal = document.getElementById('guideOpacityVal');
        const guideExport = document.getElementById('guideExport');
        guideType.value = state.guide.type;
        guideSpacing.value = state.guide.spacing; guideSpacingVal.textContent = state.guide.spacing;
        guideMargin.value = state.guide.marginLeft; guideMarginVal.textContent = state.guide.marginLeft;
        guideOpacity.value = state.guide.opacity; guideOpacityVal.textContent = state.guide.opacity;
        guideExport.checked = state.guide.includeExport;
        guideType.onchange = ()=>{ state.guide.type = guideType.value; render(); };
        guideSpacing.oninput = ()=>{ state.guide.spacing = parseInt(guideSpacing.value); guideSpacingVal.textContent = guideSpacing.value; render(); };
        guideMargin.oninput = ()=>{ state.guide.marginLeft = parseInt(guideMargin.value); guideMarginVal.textContent = guideMargin.value; render(); };
        guideOpacity.oninput = ()=>{ state.guide.opacity = parseFloat(guideOpacity.value); guideOpacityVal.textContent = guideOpacity.value; render(); };
        guideExport.onchange = ()=> state.guide.includeExport = guideExport.checked;
        guidePreset.onchange = ()=>{
          const v = guidePreset.value;
          const apply = (type, spacing, marginLeft=40, thickEvery=0, engMid=0.5)=>{ state.guide.type=type; state.guide.spacing=spacing; state.guide.marginLeft=marginLeft; state.guide.thickEvery = thickEvery; state.guide.engMid = engMid; render(); bindControls('guide'); };
          switch(v){
            case 'A7': apply('ruled', px(7), 40, 0); break;
            case 'B6': apply('ruled', px(6), 40, 0); break;
            case 'C5': apply('ruled', px(5), 40, 0); break;
            case 'U8': apply('ruled', px(8), 40, 0); break;
            case 'UL10': apply('ruled', px(10), 40, 0); break;
            case 'ENG7': apply('eng', px(7), 40, 0, 0.5); break;
            case 'DOT6': apply('dot', px(6), 40, 0); break;
            case 'GRID5': apply('grid', px(5), 0, 0); break;
            case 'GRID10': apply('grid', px(10), 0, 0); break;
            case 'ELM10': apply('grid', px(10), 0, 5); break;
            case 'ELM12': apply('grid', px(12), 0, 4); break;
            case 'ELM15': apply('grid', px(15), 0, 3); break;
          }
        };
      }
      if(tab==='text'){
        const c = document.getElementById('textColor'); const s = document.getElementById('textSize'); const sv = document.getElementById('textSizeVal'); const f = document.getElementById('textFont');
        c.value = state.text.color; s.value = state.text.size; sv.textContent=s.value; f.value = state.text.font;
        c.oninput = ()=> state.text.color = c.value;
        s.oninput = ()=>{ state.text.size = parseFloat(s.value); sv.textContent=s.value; };
        f.onchange = ()=> state.text.font = f.value;
      }
      if(tab==='bg'){
        const picker = document.getElementById('bgPicker');
        picker.value = state.bgColor;
        picker.oninput = ()=>{ state.bgColor = picker.value; render(); };
        document.querySelectorAll('.swatch').forEach(el=>{
          el.addEventListener('click', ()=>{ const c = el.getAttribute('data-c'); state.bgColor = c; picker.value = c; render(); });
        });
      }
    }

    function px(mm){ return Math.round(mm * 3.78); }

    // ====== ヘッダー操作（ページ移動・増減） ======
    const pageCount = document.getElementById('pageCount');
    const btnPrevPage = document.getElementById('btnPrevPage');
    const btnNextPage = document.getElementById('btnNextPage');
    const btnAddPage = document.getElementById('btnAddPage');
    const btnDelPage = document.getElementById('btnDelPage');

    const btnExportPng = document.getElementById('btnExportPng');
    const btnSaveDoc = document.getElementById('btnSaveDoc');
    const btnLoadDoc = document.getElementById('btnLoadDoc');
    const fileLoad = document.getElementById('fileLoad');
    const btnSetBg = document.getElementById('btnSetBg'); const fileBg = document.getElementById('fileBg');
    const btnSetPdf = document.getElementById('btnSetPdf'); const filePdf = document.getElementById('filePdf');

    function updatePageIndicator(){ pageCount.textContent = `${state.pageIndex+1} / ${state.pages.length}`; }

    btnPrevPage.onclick = ()=>{ if(state.pageIndex>0){ state.pageIndex--; updatePageIndicator(); render(); } };
    btnNextPage.onclick = ()=>{ if(state.pageIndex < state.pages.length-1){ state.pageIndex++; updatePageIndicator(); render(); } };
    btnAddPage.onclick  = ()=>{ state.pages.splice(state.pageIndex+1, 0, newPage()); state.pageIndex++; pushUndo(); updatePageIndicator(); render(); };
    btnDelPage.onclick  = ()=>{ if(state.pages.length===1){ alert('これ以上削除できません'); return; } state.pages.splice(state.pageIndex, 1); state.pageIndex = Math.max(0, state.pageIndex-1); pushUndo(); updatePageIndicator(); render(); };

    // 画像背景
    btnSetBg.onclick = ()=> fileBg.click();
    fileBg.onchange = async (e)=>{ const file = e.target.files[0]; if(!file) return; const img = new Image(); img.onload = async ()=>{ const page = state.pages[state.pageIndex]; const cnv = document.createElement('canvas'); cnv.width = img.width; cnv.height = img.height; const cctx = cnv.getContext('2d'); cctx.drawImage(img,0,0); page.bg = cnv.toDataURL('image/png'); page.bgSize = {w: img.width, h: img.height}; page.bgBitmap = await createImageBitmap(cnv); render(); }; img.src = URL.createObjectURL(file); fileBg.value = ''; };

    // PDF背景
    btnSetPdf.onclick = ()=> filePdf.click();
    filePdf.onchange = async (e)=>{
      const file = e.target.files[0]; if(!file) return;
      if(!window['pdfjsLib']){ alert('pdf.js の読み込みに失敗しました。ネット接続があるか、ローカル同梱に切り替えてください。'); return; }
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      const newPages = [];
      for(let p=1; p<=pdf.numPages; p++){
        const page = await pdf.getPage(p);
        const viewport = page.getViewport({ scale: 2 });
        const cnv = document.createElement('canvas'); cnv.width = viewport.width; cnv.height = viewport.height;
        const cctx = cnv.getContext('2d', { alpha: false });
        await page.render({ canvasContext: cctx, viewport }).promise;
        const bgUrl = cnv.toDataURL('image/png');
        const bmp = await createImageBitmap(cnv);
        const np = newPage(); np.bg = bgUrl; np.bgSize = { w: cnv.width, h: cnv.height }; np.bgBitmap = bmp;
        newPages.push(np);
      }
      const isEmpty = state.pages.length===1 && state.pages[0].strokes.length===0 && !state.pages[0].bg;
      if(isEmpty){ state.pages = newPages; state.pageIndex = 0; }
      else { state.pages.splice(state.pageIndex+1, 0, ...newPages); state.pageIndex++; }
      pushUndo(); updatePageIndicator(); render();
      filePdf.value = '';
    };

    // Undo/Redo
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    function pushUndo(){ state.undoStack.push(JSON.stringify({pages: state.pages.map(p=>({...p, bgBitmap: undefined})), pageIndex: state.pageIndex, view: state.view, guide: state.guide, pen: state.pen, hl: state.hl, eraser: state.eraser, text: state.text, bgColor: state.bgColor})); state.redoStack = []; }
    function restoreFromSnapshot(json){ const snap = JSON.parse(json); state.pages = snap.pages.map(p=>({...p, bgBitmap:null})); state.pageIndex = snap.pageIndex; state.view = snap.view; state.guide = snap.guide || state.guide; state.pen = snap.pen || state.pen; state.hl = snap.hl || state.hl; state.eraser = snap.eraser || state.eraser; state.text = snap.text || state.text; state.bgColor = snap.bgColor || state.bgColor; const cur = state.pages[state.pageIndex]; if(cur && cur.bg && !cur.bgBitmap){ const img = new Image(); img.onload = async ()=>{ const cnv=document.createElement('canvas'); cnv.width=img.width; cnv.height=img.height; cnv.getContext('2d').drawImage(img,0,0); cur.bgBitmap = await createImageBitmap(cnv); render(); }; img.src = cur.bg; } render(); updatePageIndicator(); }
    btnUndo.onclick = ()=>{ if(state.undoStack.length===0) return; const cur = JSON.stringify({pages: state.pages.map(p=>({...p, bgBitmap: undefined})), pageIndex: state.pageIndex, view: state.view, guide: state.guide, pen: state.pen, hl: state.hl, eraser: state.eraser, text: state.text, bgColor: state.bgColor}); state.redoStack.push(cur); const prev = state.undoStack.pop(); restoreFromSnapshot(prev); };
    btnRedo.onclick = ()=>{ if(state.redoStack.length===0) return; const cur = JSON.stringify({pages: state.pages.map(p=>({...p, bgBitmap: undefined})), pageIndex: state.pageIndex, view: state.view, guide: state.guide, pen: state.pen, hl: state.hl, eraser: state.eraser, text: state.text, bgColor: state.bgColor}); state.undoStack.push(cur); const next = state.redoStack.pop(); restoreFromSnapshot(next); };

    // ====== ガイド描画 ======
    function pageLogicalSize(){
      const page = state.pages[state.pageIndex];
      if(page.bgSize.w && page.bgSize.h){ return {w: page.bgSize.w, h: page.bgSize.h}; }
      const r = canvas.getBoundingClientRect();
      return { w: Math.floor(r.width), h: Math.floor(r.height) };
    }
    function drawGuide(ctx){
      const g = state.guide; if(!g || g.type==='none') return;
      const {w, h} = pageLogicalSize();
      ctx.save();
      ctx.globalAlpha = g.opacity;
      if(g.type==='ruled'){
        ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1;
        for(let y = g.spacing; y < h; y += g.spacing){ ctx.beginPath(); ctx.moveTo(0, y+0.5); ctx.lineTo(w, y+0.5); ctx.stroke(); }
        if(g.marginLeft>0){ ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(g.marginLeft+0.5, 0); ctx.lineTo(g.marginLeft+0.5, h); ctx.stroke(); }
      } else if(g.type==='eng'){
        ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1;
        for(let y = g.spacing; y < h; y += g.spacing){
          ctx.beginPath(); ctx.moveTo(0, y+0.5); ctx.lineTo(w, y+0.5); ctx.stroke();
          ctx.save(); ctx.strokeStyle = '#7c8ba0'; ctx.globalAlpha = Math.max(0.15, g.opacity*0.7);
          const mid = y - g.spacing * (1 - g.engMid);
          ctx.beginPath(); ctx.moveTo(0, mid+0.5); ctx.lineTo(w, mid+0.5); ctx.stroke(); ctx.restore();
        }
        if(g.marginLeft>0){ ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(g.marginLeft+0.5, 0); ctx.lineTo(g.marginLeft+0.5, h); ctx.stroke(); }
      } else if(g.type==='grid'){
        const k = Math.max(0, g.thickEvery|0);
        for(let y = g.spacing; y < h; y += g.spacing){ ctx.beginPath(); ctx.strokeStyle = (k && (Math.round(y/g.spacing)%k===0))? '#7f8ea3' : '#475569'; ctx.lineWidth = (k && (Math.round(y/g.spacing)%k===0))? 1.5 : 1; ctx.moveTo(0, y+0.5); ctx.lineTo(w, y+0.5); ctx.stroke(); }
        for(let x = g.spacing; x < w; x += g.spacing){ ctx.beginPath(); ctx.strokeStyle = (k && (Math.round(x/g.spacing)%k===0))? '#7f8ea3' : '#475569'; ctx.lineWidth = (k && (Math.round(x/g.spacing)%k===0))? 1.5 : 1; ctx.moveTo(x+0.5, 0); ctx.lineTo(x+0.5, h); ctx.stroke(); }
      } else if(g.type==='dot'){
        ctx.fillStyle = '#64748b'; const r = 1; const step = g.spacing;
        for(let y = step; y < h; y += step){ for(let x = step; x < w; x += step){ ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); } }
      }
      ctx.restore();
    }

    // ====== テキスト描画 ======
    function drawTexts(ctx){
      const page = state.pages[state.pageIndex];
      ctx.save();
      for(const t of page.texts){ ctx.font = `${t.size}px ${t.font}`; ctx.fillStyle = t.color; ctx.textBaseline = 'top'; ctx.fillText(t.text, t.x, t.y); }
      ctx.restore();
    }

    // ====== 描画 ======
    function drawStroke(ctx, s){ if(!s.points || s.points.length<2) return; ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.globalAlpha = s.alpha; ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.beginPath(); ctx.moveTo(s.points[0].x, s.points[0].y); for(let i=1;i<s.points.length;i++){ const p = s.points[i]; ctx.lineTo(p.x, p.y); } ctx.stroke(); ctx.globalAlpha = 1; }

    function baseRender(){
      const {width, height} = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,width,height);
      ctx.save();
      ctx.fillStyle = state.bgColor; ctx.fillRect(0,0,width,height);
      ctx.restore();
      ctx.save();
      const v = state.view; ctx.translate(v.x, v.y); ctx.scale(v.scale, v.scale);
      const page = state.pages[state.pageIndex];
      if(page.bgBitmap){ ctx.drawImage(page.bgBitmap,0,0); }
      else if(page.bg){ const img = new Image(); img.onload = async ()=>{ const cnv=document.createElement('canvas'); cnv.width=img.width; cnv.height=img.height; cnv.getContext('2d').drawImage(img,0,0); page.bgBitmap = await createImageBitmap(cnv); render(); }; img.src = page.bg; }
      drawGuide(ctx);
      for(const s of page.strokes){ drawStroke(ctx, s); }
      if(state.stroke) drawStroke(ctx, state.stroke);
      drawTexts(ctx);
      ctx.restore();
    }
    let render = baseRender;

    function effectiveSize(base, e){
      let sz = base;
      if(state.currentTool==='pen'){
        if(state.pen.pressureEnable && (e && typeof e.pressure === 'number')){ const gain = Math.max(0, state.pen.pressureGain); sz *= (0.4 + e.pressure * gain); }
        if(state.pen.tiltEnable && (typeof e.tiltX==='number' || typeof e.altitudeAngle==='number')){ let tiltFactor = 1; if(typeof e.altitudeAngle === 'number'){ const a = Math.max(0.0001, e.altitudeAngle); tiltFactor = 1 + (1 - a) * state.pen.tiltGain; } else { const t = Math.min(90, Math.sqrt((e.tiltX||0)**2 + (e.tiltY||0)**2)); tiltFactor = 1 + (t/90) * state.pen.tiltGain; } sz *= tiltFactor; }
      }
      return Math.max(0.5, Math.min(60, sz));
    }

    function toCanvasCoords(clientX, clientY){ const r = canvas.getBoundingClientRect(); const x = (clientX - r.left - state.view.x) / state.view.scale; const y = (clientY - r.top - state.view.y) / state.view.scale; return {x,y}; }

    // ====== 入力イベント ======
    let pointers = new Map();
    const textInput = document.getElementById('textInput');

    canvas.addEventListener('pointerdown', (e)=>{
      if(state.pen.palmReject && e.pointerType==='touch') return;
      if(state.pen.penOnly && !(e.pointerType==='pen' || e.pointerType==='mouse')) return;

      if(state.currentTool==='text'){
        const c = toCanvasCoords(e.clientX, e.clientY);
        textInput.style.left = (e.clientX - 6) + 'px';
        textInput.style.top = (e.clientY - 10) + 'px';
        textInput.style.display = 'block';
        textInput.value = '';
        textInput.focus();
        const onConfirm = ()=>{
          const val = textInput.value.trim();
          if(val){ const page = state.pages[state.pageIndex]; page.texts.push({ x: c.x, y: c.y, text: val, color: state.text.color, size: state.text.size, font: state.text.font }); pushUndo(); render(); }
          textInput.style.display = 'none'; textInput.value=''; textInput.onkeydown=null; textInput.onblur=null;
        };
        textInput.onkeydown = (ke)=>{ if(ke.key==='Enter'){ onConfirm(); } if(ke.key==='Escape'){ textInput.style.display='none'; textInput.value=''; } };
        textInput.onblur = ()=> onConfirm
